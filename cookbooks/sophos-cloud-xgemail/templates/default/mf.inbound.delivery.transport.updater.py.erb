#!/usr/bin/env python
# vim: autoindent expandtab filetype=python shiftwidth=4 softtabstop=4 tabstop=4
#
# Polls XGEMAIL PIC for a list of mailflow inbound customer delivery destinations
# and installs a new transport maps file for postfix
#
# Copyright: Copyright (c) 1997-2016. All rights reserved.
# Company: Sophos Limited or one of its affiliates.

import sys
sys.path.append("<%= @xgemail_utils_path %>")
import boto3
import base64
import json
import os
import requests
import subprocess
import logging
from logging.handlers import SysLogHandler


# Constants
PIC_FQDN = '<%= @xgemail_pic_fqdn %>'
POSTFIX_INSTANCE_NAME = '<%= @postfix_instance_name %>'
TRANSPORT_FILENAME = '<%= @transport_filename %>'
MAIL_PIC_RESPONSE_TIMEOUT = <%= @mail_pic_api_response_timeout %>
MAIL_PIC_API_AUTH = '<%= @mail_pic_api_auth %>'
CONNECTIONS_BUCKET = '<%= @connections_bucket %>'
POLICY_BUCKET = '<%= @policy_bucket %>'
TLS_SMTP_TRANSPORT_TAG = ' smtp_encrypt:'

# logging to syslog setup
logging.getLogger("botocore").setLevel(logging.WARNING)
logger = logging.getLogger('cd-transport-updater')
logger.setLevel(logging.INFO)
handler = logging.handlers.SysLogHandler('/dev/log')
formatter = logging.Formatter(
    '[%(name)s] %(process)d %(levelname)s %(message)s'
)
handler.formatter = formatter
logger.addHandler(handler)

PIC_XGEMAIL_API_URL = 'https://%s/mail/api/xgemail' % (PIC_FQDN)
PIC_DOMAINS_URL = PIC_XGEMAIL_API_URL + '/domains'
PIC_TLS_DOMAINS_URL = PIC_XGEMAIL_API_URL +'/tls-domain-exists/'

logger.info('customer delivery transport cron - pic url [%s]', PIC_XGEMAIL_API_URL)

def get_passphrase():
    s3 = boto3.client('s3')
    passphrase = s3.get_object(Bucket=CONNECTIONS_BUCKET, Key=MAIL_PIC_API_AUTH)
    return base64.b64encode('mail:' + passphrase['Body'].read())

auth = get_passphrase()

HEADERS = {
    'Content-type': 'application/json',
    'Authorization': 'Basic ' + auth
}

PIC_DESTINATION_URL = PIC_XGEMAIL_API_URL + '/destination'

response = requests.get(
    PIC_DOMAINS_URL,
    headers=HEADERS,
    timeout=MAIL_PIC_RESPONSE_TIMEOUT
)
response.raise_for_status()

# Returns the smtp transport tag to be used for the customer
# with the given id
def get_smtp_transport_tag(s3, domain_name, customer_id):
  return TLS_SMTP_TRANSPORT_TAG

# Expecting JSON in this form
#   {
#     "destination": "10.11.12.13",
#     "type": "IP",
#     "port": 8080,
#     "customer_id": "<customer-uuid>"
#   }
def parse_domain_response(domain_name, destinations_json, s3_client,is_custom) :
  destination_json = destinations_json['delivery_destination']
  route = destination_json['destination']
  port = destination_json['port']
  type = destination_json['type']
  customer_id = None

  if 'customer_id' in destination_json:
    customer_id = destination_json['customer_id']

  if not is_custom:
      smtp_transport_tag = get_smtp_transport_tag(
          s3_client,
          domain_name,
          customer_id
      )
  else:
      smtp_transport_tag = TLS_SMTP_TRANSPORT_TAG

  ret_val = domain_name + smtp_transport_tag

  if type != 'MX':
    ret_val += '['

  ret_val += route

  if type != 'MX':
    ret_val += ']'

  if port != 25:
    ret_val += ":" + str(port)

  return ret_val

POSTFIX_CONFIG_DIR = subprocess.check_output(
    [
      'postmulti', '-i', POSTFIX_INSTANCE_NAME, '-x',
      'postconf','-h','config_directory'
    ]
  ).rstrip()

TRANSPORT_FILE = POSTFIX_CONFIG_DIR + '/' + TRANSPORT_FILENAME
TRANSPORT_FILE_TMP = TRANSPORT_FILE + '.tmp'

with open(TRANSPORT_FILE_TMP, 'w') as f:

    s3 = boto3.client('s3')
    for domain in response.json()['domains'] :
        domain_response = requests.post(
            PIC_DESTINATION_URL,
            headers=HEADERS,
            data=json.dumps({'domain':domain}),
            timeout=MAIL_PIC_RESPONSE_TIMEOUT
          )
        domain_response.raise_for_status()
        transport_line = parse_domain_response(domain, domain_response.json(), s3,False)
        f.write('{0}\n'.format(transport_line))

    # Add catch-all to retry any unknown domain
    f.write('* retry: domain is unknown\n')

subprocess.call(['postmap', 'hash:{0}'.format(TRANSPORT_FILE_TMP)])
os.rename(TRANSPORT_FILE_TMP, TRANSPORT_FILE);
os.rename(TRANSPORT_FILE_TMP + '.db', TRANSPORT_FILE + '.db');

logger.info('transport map file [%s.db] successfully updated', TRANSPORT_FILE)
