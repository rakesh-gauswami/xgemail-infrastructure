#!/usr/bin/env python
# vim: autoindent expandtab filetype=python shiftwidth=4 softtabstop=4 tabstop=4
#
# Polls the lifecycle notification SQS and if a notification pertains to the current instance
# take action on the event
#
# Copyright: Copyright (c) 1997-2017. All rights reserved.
# Company: Sophos Limited or one of its affiliates.

import boto3
import json
import sys
import logging
import logging.handlers
import pre_termination

# SNS topic for alert notifications if any issues are encountered
ALARM_TOPIC_ARN = "<%= @alarm_topic_arn %>"
LIFECYCLE_TOPIC_SUBSCRIPTION_ARN = "<%= @lifecycle_topic_subscription_arn %>"
# general constants
AWS_REGION = "<%= @aws_region %>"
INSTANCE_ID = "<%= @instance_id %>"
SQS_LIFECYCLE_MAX_NUMBER_OF_MESSAGES = <%= @sqs_lifecycle_poller_max_number_of_messages %>
SQS_LIFECYCLE_URL = "<%= @sqs_lifecycle_url %>"
SQS_LIFECYCLE_VISIBILITY_TIMEOUT = <%= @sqs_lifecycle_poller_visibility_timeout %>
SQS_LIFECYCLE_WAIT_TIME_SECONDS = <%= @sqs_lifecycle_poller_wait_time_seconds %>
SQS_CONSUMER_SERVICE_NAME = "<%= @sqs_consumer_service_name %>"
SNS_POLICY_ARN = "<%= @sns_policy_arn %>"
SQS_POLICY_QUEUE_NAME = "<%= @sqs_policy_queue_name %>"

# logging to syslog setup
logger = logging.getLogger("lifecycle-poller")
logger.setLevel(logging.INFO)
syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
formatter = logging.Formatter(
    '[%(name)s] %(process)d %(levelname)s %(message)s'
)
syslog_handler.formatter = formatter
logger.addHandler(syslog_handler)

# Create SQS client
sqs = boto3.client('sqs', region_name=AWS_REGION)

# Create AS client
asc = boto3.client('autoscaling', region_name=AWS_REGION)

# Create SNS client
sns = boto3.client('sns', region_name=AWS_REGION)

# Load messages
response = sqs.receive_message(
    QueueUrl=SQS_LIFECYCLE_URL,
    AttributeNames=['All'],
    MaxNumberOfMessages=SQS_LIFECYCLE_MAX_NUMBER_OF_MESSAGES,
    VisibilityTimeout=SQS_LIFECYCLE_VISIBILITY_TIMEOUT,
    WaitTimeSeconds=SQS_LIFECYCLE_WAIT_TIME_SECONDS
)

def get_subscription_arn(sns, topic_arn, instance, next_token=None):
    subs = None
    logger.info('Getting all subscriptions in topic.')
    try:
        if next_token:
            subs = sns.list_subscriptions_by_topic(TopicArn=topic_arn, NextToken=next_token)
        else:
            subs = sns.list_subscriptions_by_topic(TopicArn=topic_arn)
    except botocore.exceptions.ClientError as e:
        raise e
    logger.info('Looping through Policy Subscriptions.')
    for s in subs['Subscriptions']:
        if s['Endpoint'][-19:] in instance:
            return s['SubscriptionArn']
    if subs.get('NextToken'):
        return get_subscription_arn(sns, topic_arn, instance, subs.get('NextToken'))
    return None

if "Messages" not in response:
  #no messages found exit
  logger.info('No messages found in SQS lifecycle queue')
  sys.exit(0)

# Process messages
for message in response['Messages']:
  try:
    innermessage = json.loads(json.loads(message['Body'])['Message'])
  except:
    logger.exception('ERROR parsing SQS message body')
    continue
  logger.info("Scanning SQS message: %s" % innermessage)
  # Check that sqs message is relating to an autoscaling lifecycle termination event
  if 'LifecycleActionToken' in innermessage:
    if innermessage['EC2InstanceId'] == INSTANCE_ID and innermessage['LifecycleTransition'] == 'autoscaling:EC2_INSTANCE_TERMINATING':
      logger.info('Processing SQS message for this instance')
      # Now perform all necessary logic to make sure the postfix server has empty queues before terminating
      pre_termination.service_controller('monit', 'stop')
      postfix_instance = pre_termination.get_postfix_instance()
      logger.info("Postfix Instance: %s" % postfix_instance)
      if postfix_instance == 'postfix-cd':
          if pre_termination.stop_sqs_consumer(SQS_CONSUMER_SERVICE_NAME, ALARM_TOPIC_ARN) is False:
              logger.error("Unable to continue. There is a problem with the Xgemail SQS Consumer Service.")
              sys.exit(1)
      queue_check = pre_termination.check_postfix_queue(postfix_instance)
      logger.info("Messages in Postfix queue: %d" % queue_check)
      if queue_check != 0:
          logger.warning("There are %d email messages still in the queue. We need to wait for them to drain." % queue_check)
          if pre_termination.is_postfix_queue_drained(postfix_instance, queue_check, ALARM_TOPIC_ARN) is True:
              logger.info("The wait is over. The Postfix queue is now empty.")
          else:
              logger.critical("process finished with errors.")
              sys.exit(1)
      # Remove Lifecycle SNS subscription and delete SQS queue for this instance
      logger.info("Unsubscribing this instance SQS queue from SNS topic.")
      sns.unsubscribe(SubscriptionArn=LIFECYCLE_TOPIC_SUBSCRIPTION_ARN)
      logger.info("Deleting SQS lifecycle queue for this instance.")
      sqs.delete_queue(QueueUrl=SQS_LIFECYCLE_URL)
      if postfix_instance == 'postfix-is':
          # Also Remove Policy SNS subscription and delete SQS queue for this instance
          logger.info('Getting policy queue URL.')
          sqs_policy_queue_url = sqs.get_queue_url(QueueName=SQS_POLICY_QUEUE_NAME)['QueueUrl']
          logger.info('Getting policy subscription ARN.')
          sns_policy_subscription_arn = get_subscription_arn(sns, SNS_POLICY_ARN, INSTANCE_ID)
          logger.info("Unsubscribing this instance Policy SQS queue from Policy SNS topic.")
          sns.unsubscribe(SubscriptionArn=sns_policy_subscription_arn)
          logger.info("Deleting SQS policy queue for this instance.")
          sqs.delete_queue(QueueUrl=sqs_policy_queue_url)
          logger.info("Deleting SQS policy dead letter queue for this instance.")
          sqs.delete_queue(QueueUrl=sqs.get_queue_url(QueueName=SQS_POLICY_QUEUE_NAME + '-DLQ')['QueueUrl'])
      # Complete ASG hook
      logger.info('Completing lifecycle action with CONTINUE')
      asc.complete_lifecycle_action(
        LifecycleHookName=innermessage['LifecycleHookName'],
        AutoScalingGroupName=innermessage['AutoScalingGroupName'],
        LifecycleActionToken=innermessage['LifecycleActionToken'],
        LifecycleActionResult='CONTINUE'
        )
      sys.exit(0)
  # Delete the SQS message if it is not for this instance
  logger.info('Deleting SQS message from queue, not for this instance')
  sqs.delete_message(QueueUrl=SQS_LIFECYCLE_URL, ReceiptHandle=message['ReceiptHandle'])
sys.exit(0)