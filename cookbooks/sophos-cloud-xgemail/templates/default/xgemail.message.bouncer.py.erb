#!/usr/bin/env python
# vim: autoindent expandtab filetype=python shiftwidth=4 softtabstop=4 tabstop=4
#
# Consumes bounce messages generated by postfix.
#
# Copyright: Copyright (c) 2018. All rights reserved.
# Company: Sophos Limited or one of its affiliates.
import codecs
import sys
sys.path.append("<%= @utils_dir %>")
import email
from email.header import decode_header
import json
import re
import string
from dateutil import parser
from awshandler import AwsHandler
from common.notificationsubmitinfo import NotificationSubmitInfo
import logging
from logging.handlers import SysLogHandler

AWS_REGION = "<%= @aws_region %>"
EX_TEMPFAIL = <%= @ex_tempfail_code %>
XGEMAIL_NOTIFIER_QUEUE = "<%= @notifier_sqs_url %>"
EMAIL_REGEX = "[#\w\.-]+@[\w\.-]+"
NOTIFICATION_TYPE = "FAILURE_NDR"
NOT_AVAILABLE_STR = "Not Available"

# logging to syslog setup
logging.getLogger("botocore").setLevel(logging.WARNING)
logger = logging.getLogger('messagebouncer')
logger.setLevel(logging.INFO)
handler = logging.handlers.SysLogHandler('/dev/log')
formatter = logging.Formatter(
    '[%(name)s] %(process)d %(levelname)s %(message)s'
)
handler.formatter = formatter
logger.addHandler(handler)

awshandler = AwsHandler(AWS_REGION)

def get_recipients(text, sender):
    recipients = set([])
    results = re.findall(EMAIL_REGEX, text)
    for match in results:
        if match != sender:
            recipients.add(match.encode("utf-8"))
    return(list(recipients))

def format_sender(sender_str):
    if '<' in sender_str:
        sender_str = string.replace(sender_str, '<', '')
    if '>' in sender_str:
        sender_str = string.replace(sender_str, '>', '')
    return sender_str

def add_to_sqs(sqs_url, sqs_json):
    return awshandler.add_to_sqs(
        sqs_url,
        json.dumps(sqs_json,ensure_ascii=False)
    )

def submit_notification_info_to_sqs(sender, recipients, subject, hostname, failure_txt, sent_timestamp):
    # Create a notification submit info object and submit it to Notifier listener SQS for processing
    notification_submit_info = NotificationSubmitInfo(
        NOTIFICATION_TYPE,
        sender,
        recipients,
        subject,
        hostname,
        failure_txt,
        sent_timestamp
    )
    sqs_json = notification_submit_info.get_sqs_json()
    try:
        if len(sender) > 0 :
            logger.info("Added notification submit info SQS job response [{0}] [{1}]]".format
                (add_to_sqs(
                    XGEMAIL_NOTIFIER_QUEUE,
                    sqs_json
                    ),sqs_json
                )
            )
        else :
            logger.info("Skip sending notification to SQS for empty sender [{0}]".format
                (sqs_json)
            )
    except BaseException as e:
        logger.exception("Failed send bounce message for [{0}] with error [{1}]".format(sqs_json,e))

#This function helps to identify if given encoding in input is valid according to pythong 2
def lookup_encoding(encoding):
    try:
        codecs.lookup(encoding)
        return encoding
    except BaseException as baseException:
        logger.warn("Failed to find codec {0}".format(encoding))
    return None

#This function encode try to encode string with given encoding and return utf 8
def encode_utf8(value, encoding):
    encoding=lookup_encoding(encoding)
    try:
        if encoding is not None:
            return value.decode(encoding).encode("utf-8")
        else:
            return value.decode().encode('utf-8')
    except BaseException as baseException:
        logger.warn("Failed to encode value {0} encoding {1} error {2}".format(value, encoding, baseException))
    return value.encode()

# This function performs utf 8 encoding, returns fail open string
def str_encode_utf8(value, encoding, failobj=None):
    if value is None:
        return value
    try:
        return encode_utf8(value, encoding)
    except BaseException as baseException:
        logger.warn("Failed to string encode value {0} encoding {1} error {2}".format(value, encoding, baseException))
    return failobj

def main():
    try:
        #Define default values
        subject = ''
        failure_reason = NOT_AVAILABLE_STR
        hostname = NOT_AVAILABLE_STR
        original_sender = None
        recipient = NOT_AVAILABLE_STR

        email_msg = email.message_from_file(sys.stdin)
        sent_date_str = email_msg.get('Date')
        sent_date = parser.parse(sent_date_str)
        sent_date = sent_date.isoformat()
        hostname = email_msg.get('From')
        # Get parts from body of email message and parse them to get specific information
        for part in email_msg.walk():
            # Get information from rfc822-headers part of the email.
            if part.get_content_type() == 'text/rfc822-headers':
                payload = part.get_payload()
                try:
                    payload_email = email.message_from_string(payload)
                    subject, encoding  = decode_header(payload_email.get('Subject'))[0]
                    subject=str_encode_utf8(subject,encoding,None)

                    return_path = payload_email.get('return-path')
                    original_sender = str_encode_utf8(format_sender(return_path),None,None)
                except BaseException as e:
                    logger.warn("Failed to encode subject = {0}. {1}".format(subject, e))
                # For any reason if above logic fails, following condition would work as fallback
                if subject is None or original_sender is None:
                    args = payload.split("\n")
                    for arg in args:
                        header_key = arg.split(':', 1)[0].strip().lower();
                        if subject is None and header_key.startswith('subject'):
                            subject_header = arg.split(':', 1)
                            subject = subject_header[1].strip() if len(subject_header) == 2 else ''
                            try:
                                subject, encoding = decode_header(subject)[0]
                                subject=str_encode_utf8(subject,encoding,'')
                            except BaseException as e:
                                logger.warn("Failed to encode subject = {0}. {1}".format(subject, e))
                                subject = ''

                        if original_sender is None and header_key.startswith('return-path'):
                            original_sender = str_encode_utf8(format_sender(arg.split(':', 1)[1].strip()),None,None)
            # Format is -  <recipient> : host <hostname> said: <status code> <failure_reason>
            payload_text = part.get_payload()
            if part.get_content_type() == 'text/plain' and len(payload_text) > 1:
                recipient = get_recipients(payload_text,original_sender)
                failure_reason = part.get_payload().replace('\n', ' ')
                try:
                    failure_reason, encoding = decode_header(failure_reason)[0]
                    failure_reason=str_encode_utf8(failure_reason, encoding,'Fail to deliver')
                except email.errors.HeaderParseError:
                    logger.warn("Failed to decode failure reason = {0}".format(failure_reason))
                except BaseException as e:
                    logger.exception("Failed to encode failure reason = {0}. {1}".format(failure_reason, e))

            if original_sender is None and part.get_content_type() == 'message/global-headers':
                payload = part.get_payload()
                for key in payload:
                    if key.get("Return-path") is not None:
                        original_sender=str_encode_utf8(format_sender(key.get("Return-path")),None,None)
                    if subject == '' and key.get('subject') is not None:
                        subject, encoding  = decode_header(key.get('Subject'))[0]
                        subject=str_encode_utf8(subject,encoding,None)
            logger.debug("Sender = {0}".format(original_sender))
            logger.debug("Recipient = {0}".format(recipient))
            logger.debug("Subject = {0}".format(subject))
            logger.debug("Hostname = {0}".format(hostname))
            logger.debug("Failure Reason = {0}".format(failure_reason))

        if original_sender is not None:
            submit_notification_info_to_sqs(
                original_sender,
                recipient,
                subject,
                hostname,
                failure_reason,
                sent_date
            )
        else:
            logger.error("Failed to parse original_sender from email payload {0}".format(email_msg.as_string()))

    except BaseException as e:
        logger.exception("Failed handling bounce message [{0}]".format(e))
        exit(EX_TEMPFAIL)

if __name__ == "__main__":
    main()
