#!/usr/bin/env python
# vim: autoindent expandtab filetype=python shiftwidth=4 softtabstop=4 tabstop=4
#
# Consumes bounce messages generated by postfix.
#
# Copyright: Copyright (c) 2018. All rights reserved.
# Company: Sophos Limited or one of its affiliates.

import sys
sys.path.append("<%= @utils_dir %>")
import email
from email.header import decode_header
import json
import re
import string
from dateutil import parser
from awshandler import AwsHandler
from common.notificationsubmitinfo import NotificationSubmitInfo
import logging
from logging.handlers import SysLogHandler

AWS_REGION = "<%= @aws_region %>"
EX_TEMPFAIL = <%= @ex_tempfail_code %>
XGEMAIL_NOTIFIER_QUEUE = "<%= @notifier_sqs_url %>"
EMAIL_REGEX = "[#\w\.-]+@[\w\.-]+"
NOTIFICATION_TYPE = "FAILURE_NDR"
NOT_AVAILABLE_STR = "Not Available"

# logging to syslog setup
logging.getLogger("botocore").setLevel(logging.WARNING)
logger = logging.getLogger('messagebouncer')
logger.setLevel(logging.INFO)
handler = logging.handlers.SysLogHandler('/dev/log')
formatter = logging.Formatter(
    '[%(name)s] %(process)d %(levelname)s %(message)s'
)
handler.formatter = formatter
logger.addHandler(handler)

awshandler = AwsHandler(AWS_REGION)

def get_recipients(text, sender):
    recipients = set([])
    results = re.findall(EMAIL_REGEX, text)
    for match in results:
        if match != sender:
            recipients.add(match.encode("utf-8"))
    return(list(recipients))

def format_sender(sender_str):
    if '<' in sender_str:
        sender_str = string.replace(sender_str, '<', '')
    if '>' in sender_str:
        sender_str = string.replace(sender_str, '>', '')
    return sender_str

def add_to_sqs(sqs_url, sqs_json):
    return awshandler.add_to_sqs(
        sqs_url,
        json.dumps(sqs_json)
    )

def submit_notification_info_to_sqs(sender, recipients, subject, hostname, failure_txt, sent_timestamp):
    # Create a notification submit info object and submit it to Notifier listener SQS for processing
    notification_submit_info = NotificationSubmitInfo(
        NOTIFICATION_TYPE,
        sender,
        recipients,
        subject,
        hostname,
        failure_txt,
        sent_timestamp
    )
    sqs_json = notification_submit_info.get_sqs_json()
    try:
        if len(sender) > 0 :
            logger.info("Added notification submit info SQS job response [{0}] [{1}]]".format
                (add_to_sqs(
                    XGEMAIL_NOTIFIER_QUEUE,
                    sqs_json
                    ),sqs_json
                )
            )
        else :
            logger.info("Skip sending notification to SQS for empty sender [{0}]".format
                (sqs_json)
            )
    except BaseException as e:
        logger.exception("Failed send bounce message for [{0}] with error [{1}]".format(sqs_json,e))

def main():
    try:
        #Define default values
        subject = ''
        failure_reason = NOT_AVAILABLE_STR
        hostname = NOT_AVAILABLE_STR
        original_sender = NOT_AVAILABLE_STR
        recipient = NOT_AVAILABLE_STR

        email_msg = email.message_from_file(sys.stdin)
        sent_date_str = email_msg.get('Date')
        sent_date = parser.parse(sent_date_str)
        sent_date = sent_date.isoformat()
        hostname = email_msg.get('From')
        # Get parts from body of email message and parse them to get specific information
        for part in email_msg.walk():
            # Get information from rfc822-headers part of the email.
            if part.get_content_type() == 'text/rfc822-headers':
                payload = part.get_payload()
                args = payload.split("\n")
                for arg in args:
                    header_key = arg.split(':', 1)[0].strip().lower();
                    if header_key.startswith('subject'):
                        subject_header = arg.split(':', 1)
                        subject = subject_header[1].strip() if len(subject_header) == 2 else ''
                        try:
                            subject, encoding = decode_header(subject)[0]
                            if encoding is not None:
                                subject = subject.decode(encoding).encode("utf-8")
                        except email.errors.HeaderParseError:
                            logger.warn("Failed to decode subject = {0}".format(subject) )
                            subject = ''
                        except BaseException as e:
                            logger.exception("Failed to encode subject = {0}. {1}".format(subject, e))
                            subject = ''

                    if header_key.startswith('return-path'):
                        original_sender = format_sender(arg.split(':', 1)[1].strip())
                        original_sender.encode("utf-8")
            # Format is -  <recipient> : host <hostname> said: <status code> <failure_reason>
            payload_text = part.get_payload()
            if part.get_content_type() == 'text/plain' and len(payload_text) > 1:
                recipient = get_recipients(payload_text,original_sender)
                failure_reason = part.get_payload().replace('\n', ' ')
                try:
                    failure_reason, encoding = decode_header(failure_reason)[0]
                    if encoding is not None:
                        failure_reason = failure_reason.decode(encoding).encode("utf-8")
                    else:
                        failure_reason = failure_reason.encode()
                except email.errors.HeaderParseError:
                    logger.warn("Failed to decode failure reason = {0}".format(failure_reason))
                except BaseException as e:
                    logger.exception("Failed to encode failure reason = {0}. {1}".format(failure_reason, e))
            logger.debug("Sender = {0}".format(original_sender))
            logger.debug("Recipient = {0}".format(recipient))
            logger.debug("Subject = {0}".format(subject))
            logger.debug("Hostname = {0}".format(hostname))
            logger.debug("Failure Reason = {0}".format(failure_reason))

        submit_notification_info_to_sqs(
            original_sender,
            recipient,
            subject,
            hostname,
            failure_reason,
            sent_date
        )
    except BaseException as e:
        logger.exception("Failed handling bounce message [{0}]".format(e))
        exit(EX_TEMPFAIL)

if __name__ == "__main__":
    main()
