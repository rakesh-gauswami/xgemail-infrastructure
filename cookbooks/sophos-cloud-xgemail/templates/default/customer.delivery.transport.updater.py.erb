#!/usr/bin/env python
# vim: autoindent expandtab filetype=python shiftwidth=4 softtabstop=4 tabstop=4
#
# Polls XGEMAIL PIC for a list of customer delivery destinations
# and installs a new transport maps file for postfix
#
# Copyright: Copyright (c) 1997-2016. All rights reserved.
# Company: Sophos Limited or one of its affiliates.

import argparse
import sys
sys.path.append("<%= @xgemail_utils_path %>")
import botocore
import time
import boto3
import base64
import json
import os
import requests
import subprocess
import logging
import traceback
import configformatter
from logging.handlers import SysLogHandler


# Constants
PIC_FQDN = '<%= @xgemail_pic_fqdn %>'
POSTFIX_INSTANCE_NAME = '<%= @postfix_instance_name %>'
TRANSPORT_FILENAME = '<%= @transport_filename %>'
MAIL_PIC_RESPONSE_TIMEOUT = <%= @mail_pic_api_response_timeout %>
MAIL_PIC_API_AUTH = '<%= @mail_pic_api_auth %>'
CONNECTIONS_BUCKET = '<%= @connections_bucket %>'
POLICY_BUCKET = '<%= @policy_bucket %>'
ENC_CONFIG_KEY = '<%= @enc_config_key %>'
INBOUND_TLS_CONFIG_KEY = '<%= @inbound_tls_config_key %>'
TLS_SMTP_TRANSPORT_TAG = ' smtp_encrypt:'
DEFAULT_SMTP_TRANSPORT_TAG = ' smtp:'
CUSTOM_ROUTE_TRANSPORT_PATH = "<%= @custom_route_transport_path %>"
CUSTOM_RECIPIENT_TRANSPORT_FILE_NAME = CUSTOM_ROUTE_TRANSPORT_PATH + "customer-delivery-custom-recipient-transport.CONFIG"

# logging to syslog setup
logging.getLogger("botocore").setLevel(logging.WARNING)
logger = logging.getLogger('cd-transport-updater')
logger.setLevel(logging.INFO)
handler = logging.handlers.SysLogHandler('/dev/log')
formatter = logging.Formatter(
    '[%(name)s] %(process)d %(levelname)s %(message)s'
)
handler.formatter = formatter
logger.addHandler(handler)

PIC_XGEMAIL_API_URL = 'https://%s/mail/api/xgemail' % (PIC_FQDN)
PIC_DOMAINS_URL = PIC_XGEMAIL_API_URL + '/domains'
PIC_TLS_DOMAINS_URL = PIC_XGEMAIL_API_URL +'/tls-domain-exists/'

logger.debug('customer delivery transport updater - pic url [%s]', PIC_XGEMAIL_API_URL)

def get_passphrase():
    s3 = boto3.client('s3')
    passphrase = s3.get_object(Bucket=CONNECTIONS_BUCKET, Key=MAIL_PIC_API_AUTH)
    return base64.b64encode('mail:' + passphrase['Body'].read())

# Returns the smtp transport tag to be used for the customer
# with the given id
def get_smtp_transport_tag(s3, domain_name, customer_id):

  if encryption_config_exists(s3, domain_name):
    return TLS_SMTP_TRANSPORT_TAG

  if tls_config_exists_in_api_response(customer_id):
    return TLS_SMTP_TRANSPORT_TAG

  return DEFAULT_SMTP_TRANSPORT_TAG

# sort custom record so that email will prior to it domain
def sort_record_key(unsorted_dict):
    sorted_keys = unsorted_dict.keys()
    list_of_email=[]
    list_of_domain=[]
    for key in sorted_keys:
        if '@' in key:
            list_of_email.append(key)
        else:
            list_of_domain.append(key)
    return list_of_email + list_of_domain

# Checks for the existence of at least one TLS configuration belonging to the customer with given id
def tls_config_exists_in_api_response(customer_id):
  try:
    logger.debug("Calling api [%s] for customer_id [%s] ", PIC_TLS_DOMAINS_URL, customer_id)
    response = requests.get(
      PIC_TLS_DOMAINS_URL + customer_id,
      headers=HEADERS,
      timeout=MAIL_PIC_RESPONSE_TIMEOUT
    )
    response.raise_for_status()
    logger.debug("API response for customer id [%s] : [%s]", customer_id, response)
    tls_response = response.json()
    return tls_response['tls_domains_exsist']
  except botocore.exceptions.ClientError as e:
    logger.warn("Error [%s] occurred while calling api [%s] for customer_id [%s] ", e, PIC_TLS_DOMAINS_URL, customer_id)
    return False

# Checks if encryption config exists for the given domain
def encryption_config_exists(s3_client, domain_name):

  if not POLICY_BUCKET:
    return False

  key_path = ENC_CONFIG_KEY + domain_name + '.ENC_CONFIG'

  try:
    s3_client.head_object(Bucket = POLICY_BUCKET, Key = key_path)
    logger.debug("key (%s) exists!", key_path)
    return True
  except botocore.exceptions.ClientError as e:
    return False

# Expecting JSON in this form
#   {
#     "destination": "10.11.12.13",
#     "type": "IP",
#     "port": 8080,
#     "customer_id": "<customer-uuid>"
#   }
def parse_domain_response(domain_name, destinations_json, s3_client,is_custom) :
  destination_json = destinations_json['delivery_destination']
  route = destination_json['destination']
  port = destination_json['port']
  type = destination_json['type']
  customer_id = None

  if 'customer_id' in destination_json:
    customer_id = destination_json['customer_id']

  if not is_custom:
      smtp_transport_tag = get_smtp_transport_tag(
          s3_client,
          domain_name,
          customer_id
      )
  else:
      smtp_transport_tag = TLS_SMTP_TRANSPORT_TAG

  ret_val = domain_name + smtp_transport_tag

  if type != 'MX':
    ret_val += '['

  ret_val += route

  if type != 'MX':
    ret_val += ']'

  if port != 25:
    ret_val += ":" + str(port)

  return ret_val

def custom_route_file_exist():
  s3 = boto3.client('s3')
  try:
      s3.head_object(Bucket=POLICY_BUCKET,Key=CUSTOM_RECIPIENT_TRANSPORT_FILE_NAME)
      # custom route file found return true
      return True
  except botocore.exceptions.ClientError as e:
      trace = traceback.format_exc()
      logger.debug("Custom route file not Exist." + trace)
      return False

transport_updater_parser = argparse.ArgumentParser(description='Used to update postfix transport files')
transport_updater_parser.add_argument('--daemon', choices=['True', 'False'], help='Whether to run script as daemon', default='False')
transport_updater_parser_args = transport_updater_parser.parse_args()

if transport_updater_parser_args.daemon == 'True':
  logger.debug('daemon argument is true')

auth = get_passphrase()

HEADERS = {
    'Content-type': 'application/json',
    'Authorization': 'Basic ' + auth
}

PIC_DESTINATION_URL = PIC_XGEMAIL_API_URL + '/destination'

while True:

  timestamp_start=time.time() * 1000

  POSTFIX_CONFIG_DIR = subprocess.check_output(
      [
        'postmulti', '-i', POSTFIX_INSTANCE_NAME, '-x',
        'postconf','-h','config_directory'
      ]
    ).rstrip()

  TRANSPORT_FILE = POSTFIX_CONFIG_DIR + '/' + TRANSPORT_FILENAME
  TRANSPORT_FILE_TMP = TRANSPORT_FILE + '.tmp'

  logger.info('starting to update transport map file [%s.db]', TRANSPORT_FILE)

  response = requests.get(
      PIC_DOMAINS_URL,
      headers=HEADERS,
      timeout=MAIL_PIC_RESPONSE_TIMEOUT
  )

  if response.status_code != 200:
    logger.warn("Got response code [{}] from mail pic".format(response.status_code));

  response.raise_for_status()

  with open(TRANSPORT_FILE_TMP, 'w') as f:

    s3 = boto3.client('s3')

    if custom_route_file_exist():
      try:
          current_config = s3.get_object(Bucket=POLICY_BUCKET,Key= CUSTOM_RECIPIENT_TRANSPORT_FILE_NAME)
          raw_config_data= current_config['Body'].read()
          config_data = configformatter.get_config_binary(raw_config_data)
          record = json.loads(config_data)

          sorted_record_keys=sort_record_key(record)
          for domain_or_email in sorted_record_keys :
              transport_line = parse_domain_response(domain_or_email,record[domain_or_email] , s3, True)
              f.write('{0}\n'.format(transport_line))
      except Exception as e:
          trace = traceback.format_exc()
          for line in trace.splitlines():
              logger.debug("Error loading custom Transport " + line)

    for domain in response.json()['domains'] :
      domain_response = requests.post(
          PIC_DESTINATION_URL,
          headers=HEADERS,
          data=json.dumps({'domain':domain}),
          timeout=MAIL_PIC_RESPONSE_TIMEOUT
        )
      domain_response.raise_for_status()
      transport_line = parse_domain_response(domain, domain_response.json(), s3, False)
      f.write('{0}\n'.format(transport_line))
      if (float(round(time.time() * 1000)) - float(timestamp_start)) > 15 * 60 * 1000:
        logger.info('transport map file updater taken more than 15 mins')

    # Add catch-all to retry any unknown domain
    f.write('* retry: domain is unknown\n')

  subprocess.call(['postmap', 'hash:{0}'.format(TRANSPORT_FILE_TMP)])
  os.rename(TRANSPORT_FILE_TMP, TRANSPORT_FILE);
  os.rename(TRANSPORT_FILE_TMP + '.db', TRANSPORT_FILE + '.db');

  logger.info('transport map file [%s.db] successfully updated. Time taken [%s]', TRANSPORT_FILE, float(round(time.time() * 1000)) - float(timestamp_start))

  if transport_updater_parser_args.daemon == 'False':
    logger.info('daemon argument is false')
    break