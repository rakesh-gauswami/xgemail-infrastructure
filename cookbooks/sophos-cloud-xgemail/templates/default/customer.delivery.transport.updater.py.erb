#!/usr/bin/env python
# vim: autoindent expandtab filetype=python shiftwidth=4 softtabstop=4 tabstop=4
#
# Polls XGEMAIL PIC for a list of customer delivery destinations
# and installs a new transport maps file for postfix
#
# Copyright: Copyright (c) 1997-2016. All rights reserved.
# Company: Sophos Limited or one of its affiliates.

import boto3
import base64
import json
import os
import requests
import subprocess
import logging
import sys
from logging.handlers import SysLogHandler

# Constants
PIC_CA_PATH = '<%= @xgemail_pic_ca_path %>'
PIC_FQDN = '<%= @xgemail_pic_fqdn %>'
POSTFIX_INSTANCE_NAME = '<%= @postfix_instance_name %>'
TRANSPORT_FILENAME = '<%= @transport_filename %>'
MAIL_PIC_RESPONSE_TIMEOUT = <%= @mail_pic_api_response_timeout %>
MAIL_PIC_API_AUTH = '<%= @mail_pic_api_auth %>'
CONNECTIONS_BUCKET = '<%= @connections_bucket %>'

ENC_CONFIG_BUCKET = '<%= @policy_bucket %>'
ENC_CONFIG_KEY = 'config/outbound-relay-control/encryption/'

# logging to syslog setup
logging.getLogger("botocore").setLevel(logging.WARNING)
logger = logging.getLogger('cd-transport-updater')
logger.setLevel(logging.INFO)
handler = logging.handlers.SysLogHandler('/dev/log')
formatter = logging.Formatter(
    '[%(name)s] %(process)d %(levelname)s %(message)s'
)
handler.formatter = formatter
logger.addHandler(handler)

PIC_XGEMAIL_API_URL = 'https://%s/mail/api/xgemail' % (PIC_FQDN)
PIC_DOMAINS_URL = PIC_XGEMAIL_API_URL + '/domains'

logger.info('customer delivery transport cron - pic url [%s]', PIC_XGEMAIL_API_URL)

def get_passphrase():
    s3 = boto3.client('s3')
    passphrase = s3.get_object(Bucket=CONNECTIONS_BUCKET, Key=MAIL_PIC_API_AUTH)
    return base64.b64encode('mail:' + passphrase['Body'].read())

auth = get_passphrase()

HEADERS = {
    'Content-type': 'application/json',
    'Authorization': 'Basic ' + auth
}

PIC_DESTINATION_URL = PIC_XGEMAIL_API_URL + '/destination'

response = requests.get(
    PIC_DOMAINS_URL,
    headers=HEADERS,
    verify=PIC_CA_PATH,
    timeout=MAIL_PIC_RESPONSE_TIMEOUT
)
response.raise_for_status()

# Check if bucket in 'bucket_path' exists or not
def check_bucket(s3, key_path):
    try:
      s3.head_object(Bucket = ENC_CONFIG_BUCKET, Key = key_path)
      logger.info("key (%s) exists!", key_path)
      return True
    except botocore.exceptions.ClientError as e:
      # If a client error is thrown, then check that it was a 404 error.
      # If it was a 404 error, then the key does not exist.
      error_code = int(e.response['Error']['Code'])
      if error_code == 403:
          logger.info("Private bucket. Forbidden Access!")
          return True
      elif error_code == 404:
          return False

# Expecting JSON in this form
#   {
#     "destination": "10.11.12.13",
#     "type": "IP",
#     "port": 8080
#   }
def parse_domain_response(domain_name, destinations_json) :
  destination_json = destinations_json['delivery_destination']
  route = destination_json['destination']
  port = destination_json['port']
  type = destination_json['type']

  s3 = boto3.client('s3')
  enc_bucket = ENC_CONFIG_KEY + domain_name + '.ENC_CONFIG'

  if (check_bucket(s3, enc_bucket) == True):
    ret_val = domain_name + ' smtp:'
  else:
    ret_val = domain_name + ' smtp_encrypt:'

  if (type != 'MX'):
    ret_val += '['

  ret_val += route

  if (type != 'MX'):
    ret_val += ']'

  if (port != 25):
    ret_val += ":" + str(port)

  return ret_val

POSTFIX_CONFIG_DIR = subprocess.check_output(
    [
      'postmulti', '-i', POSTFIX_INSTANCE_NAME, '-x',
      'postconf','-h','config_directory'
    ]
  ).rstrip()

TRANSPORT_FILE = POSTFIX_CONFIG_DIR + '/' + TRANSPORT_FILENAME
TRANSPORT_FILE_TMP = TRANSPORT_FILE + '.tmp'

with open(TRANSPORT_FILE_TMP, 'w') as f:
  for domain in response.json()['domains'] :
    domain_response = requests.post(
        PIC_DESTINATION_URL,
        headers=HEADERS,
        data=json.dumps({'domain':domain}),
        verify=PIC_CA_PATH,
        timeout=MAIL_PIC_RESPONSE_TIMEOUT
      )
    domain_response.raise_for_status()
    transport_line = parse_domain_response(domain, domain_response.json())
    f.write('{0}\n'.format(transport_line))

  # Add catch-all to retry any unknown domain
  f.write('* retry: domain is unknown\n')

subprocess.call(['postmap', 'hash:{0}'.format(TRANSPORT_FILE_TMP)])
os.rename(TRANSPORT_FILE_TMP, TRANSPORT_FILE);
os.rename(TRANSPORT_FILE_TMP + '.db', TRANSPORT_FILE + '.db');

logger.info('transport map file [%s.db] successfully updated', TRANSPORT_FILE)
