#!/usr/bin/env python
# vim: autoindent expandtab filetype=python shiftwidth=4 softtabstop=4 tabstop=4
#
# Polls XGEMAIL PIC for a list of customer delivery destinations
# and installs a new transport maps file for postfix
#
# Copyright: Copyright (c) 1997-2016. All rights reserved.
# Company: Sophos Limited or one of its affiliates.

import base64
import json
import logging
import os
import subprocess
from logging.handlers import SysLogHandler

import boto3
import botocore
import requests

# Constants
PIC_FQDN = '<%= @xgemail_pic_fqdn %>'
POSTFIX_INSTANCE_NAME = '<%= @postfix_instance_name %>'
TRANSPORT_FILENAME = '<%= @transport_filename %>'
MAIL_PIC_RESPONSE_TIMEOUT = <%= @mail_pic_api_response_timeout %>
MAIL_PIC_API_AUTH = '<%= @mail_pic_api_auth %>'
CONNECTIONS_BUCKET = '<%= @connections_bucket %>'
POLICY_BUCKET = '<%= @policy_bucket %>'
ENC_CONFIG_KEY = '<%= @enc_config_key %>'
INBOUND_TLS_CONFIG_KEY = '<%= @inbound_tls_config_key %>'
TLS_SMTP_TRANSPORT_TAG = ' smtp_encrypt:'
DEFAULT_SMTP_TRANSPORT_TAG = ' smtp:'

# logging to syslog setup
logging.getLogger("botocore").setLevel(logging.WARNING)
logger = logging.getLogger('cd-transport-updater')
logger.setLevel(logging.INFO)
handler = logging.handlers.SysLogHandler('/dev/log')
formatter = logging.Formatter(
    '[%(name)s] %(process)d %(levelname)s %(message)s'
)
handler.formatter = formatter
logger.addHandler(handler)

PIC_XGEMAIL_API_URL = 'https://%s/mail/api/xgemail' % (PIC_FQDN)
PIC_DOMAINS_URL = PIC_XGEMAIL_API_URL + '/domains'
PIC_TLS_DOMAINS_URL = PIC_XGEMAIL_API_URL +'/tls-domain-exists/'

logger.info('customer delivery transport cron - pic url [%s]', PIC_XGEMAIL_API_URL)

def get_passphrase():
    s3 = boto3.client('s3')
    passphrase = s3.get_object(Bucket=CONNECTIONS_BUCKET, Key=MAIL_PIC_API_AUTH)
    return base64.b64encode('mail:' + passphrase['Body'].read())

auth = get_passphrase()

HEADERS = {
    'Content-type': 'application/json',
    'Authorization': 'Basic ' + auth
}

PIC_DESTINATION_URL = PIC_XGEMAIL_API_URL + '/destination'

response = requests.get(
    PIC_DOMAINS_URL,
    headers=HEADERS,
    timeout=MAIL_PIC_RESPONSE_TIMEOUT
)
response.raise_for_status()

# Returns the smtp transport tag to be used for the customer
# with the given id
def get_smtp_transport_tag(s3, domain_name, customer_id):

  if encryption_config_exists(s3, domain_name):
    return TLS_SMTP_TRANSPORT_TAG

  if tls_config_exists_in_api_response(customer_id):
    return TLS_SMTP_TRANSPORT_TAG

  return DEFAULT_SMTP_TRANSPORT_TAG


# Checks for the existence of at least one TLS configuration belonging to the customer with given id
def tls_config_exists_in_api_response(customer_id):
  try:
    logger.debug("Calling api [%s] for customer_id [%s] ", PIC_TLS_DOMAINS_URL, customer_id)
    response = requests.get(
      PIC_TLS_DOMAINS_URL + customer_id,
      headers=HEADERS,
      timeout=MAIL_PIC_RESPONSE_TIMEOUT
    )
    response.raise_for_status()
    logger.debug("API response for customer id [%s] : [%s]", customer_id, response)
    tls_response = response.json()
    return tls_response['tls_domains_exsist']
  except botocore.exceptions.ClientError as e:
    logger.warn("Error [%s] occurred while calling api [%s] for customer_id [%s] ", e, PIC_TLS_DOMAINS_URL, customer_id)
    return False


# Checks for the existence of at least one TLS configuration file
# belonging to the customer with the given id
def tls_config_exists(s3_client, customer_id):

  customer_path = INBOUND_TLS_CONFIG_KEY + customer_id

  try:
    list_response = s3_client.list_objects(
      Bucket = POLICY_BUCKET,
      MaxKeys = 1,
      Prefix = customer_path
    )

    if not 'Contents' in list_response:
      return False

    return len(list_response['Contents']) > 0

  except botocore.exceptions.ClientError as e:
    return False


# Checks if encryption config exists for the given domain
def encryption_config_exists(s3_client, domain_name):

  if not POLICY_BUCKET:
    return False

  key_path = ENC_CONFIG_KEY + domain_name + '.ENC_CONFIG'

  try:
    s3_client.head_object(Bucket = POLICY_BUCKET, Key = key_path)
    logger.debug("key (%s) exists!", key_path)
    return True
  except botocore.exceptions.ClientError as e:
    return False

# Expecting JSON in this form
#   {
#     "destination": "10.11.12.13",
#     "type": "IP",
#     "port": 8080,
#     "customer_id": "<customer-uuid>"
#   }
def parse_domain_response(domain_name, destinations_json, s3_client) :
  destination_json = destinations_json['delivery_destination']
  route = destination_json['destination']
  port = destination_json['port']
  type = destination_json['type']
  customer_id = None

  if 'customer_id' in destination_json:
    customer_id = destination_json['customer_id']

  smtp_transport_tag = get_smtp_transport_tag(
    s3_client,
    domain_name,
    customer_id
  )

  ret_val = domain_name + smtp_transport_tag

  if type != 'MX':
    ret_val += '['

  ret_val += route

  if type != 'MX':
    ret_val += ']'

  if port != 25:
    ret_val += ":" + str(port)

  return ret_val

POSTFIX_CONFIG_DIR = subprocess.check_output(
    [
      'postmulti', '-i', POSTFIX_INSTANCE_NAME, '-x',
      'postconf','-h','config_directory'
    ]
  ).rstrip()

TRANSPORT_FILE = POSTFIX_CONFIG_DIR + '/' + TRANSPORT_FILENAME
TRANSPORT_FILE_TMP = TRANSPORT_FILE + '.tmp'

with open(TRANSPORT_FILE_TMP, 'w') as f:

  s3 = boto3.client('s3')

  for domain in response.json()['domains'] :
    domain_response = requests.post(
        PIC_DESTINATION_URL,
        headers=HEADERS,
        data=json.dumps({'domain':domain}),
        timeout=MAIL_PIC_RESPONSE_TIMEOUT
      )
    domain_response.raise_for_status()
    transport_line = parse_domain_response(domain, domain_response.json(), s3)
    f.write('{0}\n'.format(transport_line))

  # Add catch-all to retry any unknown domain
  f.write('* retry: domain is unknown\n')

subprocess.call(['postmap', 'hash:{0}'.format(TRANSPORT_FILE_TMP)])
os.rename(TRANSPORT_FILE_TMP, TRANSPORT_FILE);
os.rename(TRANSPORT_FILE_TMP + '.db', TRANSPORT_FILE + '.db');

logger.info('transport map file [%s.db] successfully updated', TRANSPORT_FILE)
